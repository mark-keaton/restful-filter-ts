// Generated by dts-bundle-generator v6.4.0

/**
Configuration parameters for the parser.

Defaults:
case_sensitive: false
page_param_name: "page"
limit_param_name: "count",
per_page: 20
max_count_per_page: 100
order_param_name: "order_by"
*/
export interface IConfig {
	case_sensitive: boolean;
	limit_param_name: string;
	max_count_per_page: number;
	order_param_name: string;
	page_param_name: string;
	per_page: number;
}
/**
Possible types allowed  for the filter values
*/
export type FilterValue = string | number | boolean | string[] | number[] | boolean[];
/**
The parsed filter query object for consumption by library
*/
export interface IFilterObject {
	operator: string;
	operatorSQL: string | string[];
	column: string;
	value: FilterValue;
}
/**
Offset and limit arguments for pagination
*/
export interface IPaginationObject {
	offset: number;
	limit: number;
}
/**
Querystring arguments parsed into an object.
*/
export interface IQueryObject {
	[key: string]: any;
}
/**
Curried Parse function with config in closure
*/
export interface IConfiguredParse {
	parse: (queryObject: IQueryObject, allowedKeys?: string[] | null) => IParsedQueryObject;
}
export type Column = string;
export type Order = "ASC" | "DESC";
export type ParsedOrderBy = [
	Column,
	Order
];
export interface IParsedQueryObject {
	filter: IFilterObject[];
	order: ParsedOrderBy[];
	paginate: IPaginationObject;
}
export declare const OPERATORS: {
	__eq: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__ne: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__lte: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__gte: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__lt: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__gt: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__not: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__in: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__notin: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__like: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__ilike: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__notlike: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__notilike: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__contains: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__between: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
	__notbetween: {
		parser: (column: string, value: FilterValue) => IFilterObject;
	};
};
declare const init: (config?: Partial<IConfig>) => IConfiguredParse;
export default init;

export {};
